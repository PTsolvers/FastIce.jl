var documenterSearchIndex = {"docs":
[{"location":"lib/modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"lib/modules/#Grids","page":"Modules","title":"Grids","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [FastIce.Grids]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#FastIce.Grids.CartesianGrid","page":"Modules","title":"FastIce.Grids.CartesianGrid","text":"Rectilinear grid with uniform spacing.\n\nExamples\n\njulia> using FastIce.Grids\n\njulia> grid = CartesianGrid(origin=(0.0,0.0), extent=(1.0,1.0), size=(4,4))\n2D 4×4 CartesianGrid{Float64}:\n    x ∈ [0.0–1.0]; Δx = 0.25\n    y ∈ [0.0–1.0]; Δy = 0.25\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#FastIce.Grids.CartesianGrid-Union{Tuple{}, Tuple{I}, Tuple{T}, Tuple{N}} where {N, T, I}","page":"Modules","title":"FastIce.Grids.CartesianGrid","text":"CartesianGrid(; origin::NTuple{N,T}, extent::NTuple{N,T}, size::NTuple{N,I})\n\nCreate a Cartesian grid with a specified origin (bottom-south-west corner in 3D), spatial extent, and number of grid cells.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.DiscreteAxis","page":"Modules","title":"FastIce.Grids.DiscreteAxis","text":"Discretised one-dimensional interval. Grid type CartesianGrid is defined as a tuple of DiscreteAxis's.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#FastIce.Grids.axis-Tuple{FastIce.Grids.CartesianGrid, Integer}","page":"Modules","title":"FastIce.Grids.axis","text":"axis(grid::CartesianGrid, dim::Integer)\n\nReturn a DiscreteAxis corresponding to the spatial dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.coord-Union{Tuple{N}, Tuple{FastIce.Grids.CartesianGrid{N}, Tuple{Vararg{FastIce.Grids.Location, N}}, Tuple{Vararg{T, N}} where T}} where N","page":"Modules","title":"FastIce.Grids.coord","text":"coord(grid::CartesianGrid{N}, loc::NTuple{N,Location}, inds::NTuple{N})\n\nReturn a tuple of spatial coordinates of a grid point at location loc and indices inds.\n\nFor vertex-centered locations, first grid point is at the origin. For cell-centered locations, first grid point at half-spacing distance from the origin.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.extent-Tuple{FastIce.Grids.CartesianGrid}","page":"Modules","title":"FastIce.Grids.extent","text":"extent(grid::CartesianGrid)\n\nReturn the spatial extent of a CartesianGrid as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.origin-Tuple{FastIce.Grids.CartesianGrid}","page":"Modules","title":"FastIce.Grids.origin","text":"origin(grid::CartesianGrid)\n\nReturn the origin of a CartesianGrid. The origin corresponds to bottom-south-west corner of the grid in 3D.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.spacing-Tuple{FastIce.Grids.CartesianGrid}","page":"Modules","title":"FastIce.Grids.spacing","text":"spacing(grid::CartesianGrid)\n\nReturn the spacing of a CartesianGrid as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Grids.Δ-Tuple{FastIce.Grids.CartesianGrid}","page":"Modules","title":"FastIce.Grids.Δ","text":"Δ(grid::CartesianGrid)\n\nReturn the spacing of a CartesianGrid as a tuple. Same as spacing.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Distributed","page":"Modules","title":"Distributed","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [FastIce.Distributed]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#FastIce.Architectures.Architecture-Tuple{KernelAbstractions.Backend, FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Architectures.Architecture","text":"Architecture(backend::Backend, topology::CartesianTopology) where {N}\n\nCreate a distributed Architecture using backend and topology. For GPU backends, device will be selected automatically based on a process id within a node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.CartesianTopology","page":"Modules","title":"FastIce.Distributed.CartesianTopology","text":"CartesianTopology\n\nRepresents N-dimensional Cartesian topology of distributed processes.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#FastIce.Distributed.CartesianTopology-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N","page":"Modules","title":"FastIce.Distributed.CartesianTopology","text":"CartesianTopology(dims::NTuple{N,Int}; comm=MPI.COMM_WORLD) where {N}\n\nCreate an N-dimensional Cartesian topology with dimensions dims and using base MPI communicator comm (by default, comm=MPI.COMM_WORLD). If all entries in dims are not equal to 0, the product of dims should be equal to the total number of MPI processes MPI.Comm_size(comm). If any (or all) entries of dims are 0, the dimensions in the corresponding spatial directions will be picked automatically.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.DistributedMPI","page":"Modules","title":"FastIce.Distributed.DistributedMPI","text":"Trait structure used as a type parameter to indicate that the Architecture is a distributed MPI Architecture.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#FastIce.Distributed.ExchangeInfo","page":"Modules","title":"FastIce.Distributed.ExchangeInfo","text":"ExchangeInfo\n\nStructure containing the information to exchange halos of one side of an N-dimensional array.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#FastIce.Distributed.ExchangeInfo-Union{Tuple{D}, Tuple{S}, Tuple{Val{S}, Val{D}, FastIce.Fields.Field}} where {S, D}","page":"Modules","title":"FastIce.Distributed.ExchangeInfo","text":"ExchangeInfo(::Val{S}, ::Val{D}, field::Field) where {S,D}\n\nCreate ExchangeInfo to exchange halos on side S in the spatial direction D.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.BoundaryConditions.apply_boundary_conditions!-Union{Tuple{N}, Tuple{D}, Tuple{S}, Tuple{Val{S}, Val{D}, FastIce.Architectures.Architecture, FastIce.Grids.CartesianGrid, Tuple{Vararg{FastIce.Fields.Field, N}}, Tuple{Vararg{FastIce.Distributed.ExchangeInfo, N}}}} where {S, D, N}","page":"Modules","title":"FastIce.BoundaryConditions.apply_boundary_conditions!","text":"apply_boundary_conditions!(::Val{S}, ::Val{D},\n                           arch::Architecture,\n                           grid::CartesianGrid,\n                           fields::NTuple{N,Field},\n                           exchange_infos::NTuple{N,ExchangeInfo}; async=true) where {S,D,N}\n\nPerform a non-blocking MPI exchange for a set of fields.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.cartesian_communicator-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.cartesian_communicator","text":"cartesian_communicator(t::CartesianTopology)\n\nMPI Cartesian communicator for the topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.coordinates-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.coordinates","text":"coordinates(t::CartesianTopology)\n\nCoordinates of a current process within a Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.dimensions-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.dimensions","text":"dimensions(t::CartesianTopology)\n\nDimensions of the topology as NTuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.gather!-Tuple{FastIce.Architectures.Architecture{FastIce.Distributed.DistributedMPI}, Any, FastIce.Fields.Field}","page":"Modules","title":"FastIce.Distributed.gather!","text":"gather!(arch::Architecture{DistributedMPI}, dst, src::Field; kwargs...)\n\nGather the interior of a field src into a global array dst.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.gather!-Union{Tuple{N}, Tuple{T}, Tuple{Union{Nothing, AbstractArray{T, N}}, AbstractArray{T, N}, MPI.Comm}} where {T, N}","page":"Modules","title":"FastIce.Distributed.gather!","text":"gather!(dst::Union{AbstractArray{T,N},Nothing}, src::AbstractArray{T,N}, comm::MPI.Comm; root=0) where {T,N}\n\nGather local array src into a global array dst. Size of the global array size(dst) should be equal to the product of the size of a local array size(src) and the dimensions of a Cartesian communicator comm. The array will be gathered on the process with id root (root=0 by default). Note that the memory for a global array should be allocated only on the process with id root, on other processes dst can be set to nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.global_grid_size-Tuple{FastIce.Distributed.CartesianTopology, Any}","page":"Modules","title":"FastIce.Distributed.global_grid_size","text":"global_grid_size(t::CartesianTopology, local_size)\n\nReturn the global size for a structured grid.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.global_rank-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.global_rank","text":"global_rank(t::CartesianTopology)\n\nGlobal id of a process in a Cartesian topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.global_size-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.global_size","text":"global_size(t::CartesianTopology)\n\nTotal number of processes withing the topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.has_neighbor-Tuple{FastIce.Distributed.CartesianTopology, Any, Any}","page":"Modules","title":"FastIce.Distributed.has_neighbor","text":"has_neighbor(t::CartesianTopology, dim, side)\n\nReturns true if there a neighbor process in spatial direction dim on the side side, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.local_grid-Tuple{FastIce.Grids.CartesianGrid, FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.local_grid","text":"local_grid(g::CartesianGrid, t::CartesianTopology)\n\nReturn a CartesianGrid covering the subdomain which corresponds to the current process.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.neighbor-Tuple{FastIce.Distributed.CartesianTopology, Any, Any}","page":"Modules","title":"FastIce.Distributed.neighbor","text":"neighbor(t::CartesianTopology, dim, side)\n\nReturns id of a neighbor process in spatial direction dim on the side side, if this neighbor exists, or MPI.PROC_NULL otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.neighbors-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.neighbors","text":"neighbors(t::CartesianTopology)\n\nNeighbors of a current process.\n\nReturns NTuple containing process ids of the two immediate neighbors in each spatial direction, or MPI.PROC_NULL if no neighbor on a corresponding side.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.node_name-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.node_name","text":"node_name(t::CartesianTopology)\n\nName of a node according to MPI.Get_processor_name().\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.node_size-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.node_size","text":"node_size(t::CartesianTopology)\n\nNumber of processes sharing the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.shared_communicator-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.shared_communicator","text":"shared_communicator(t::CartesianTopology)\n\nMPI communicator for the processes sharing the same node.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Distributed.shared_rank-Tuple{FastIce.Distributed.CartesianTopology}","page":"Modules","title":"FastIce.Distributed.shared_rank","text":"shared_rank(t::CartesianTopology)\n\nLocal id of a process within a single node. Can be used to set the GPU device.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Kernel-launch","page":"Modules","title":"Kernel launch","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [FastIce.KernelLaunch]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#FastIce.KernelLaunch.launch!-Union{Tuple{Args}, Tuple{K}, Tuple{FastIce.Architectures.Architecture, FastIce.Grids.CartesianGrid, Pair{K, Args}}} where {K, Args}","page":"Modules","title":"FastIce.KernelLaunch.launch!","text":"launch!(arch::Architecture, grid::CartesianGrid, kernel::Pair{K,Args}; <keyword arguments>) where {K,Args}\n\nLaunch a KernelAbstraction kernel on a grid using the backend from arch. Either worksize or location must be provided as keyword arguments.\n\nKeyword Arguments\n\nworksize: worksize of a kernel, i.e. how many grid points are included in each spatial direction.\nlocation[=nothing]: compute worksize as a size of the grid at a specified location.   If only one location is provided, e.g. location=Vertex(), then this location will be used for all spacial directions.\noffset[=nothing]: index offset for all grid indices as a CartesianIndex.\nexpand[=nothing]: if provided, the worksize is increased by 2*expand, and offset is set to -expand, or combined with user-provided offset.\nhide_boundaries[=nothing]: instance of HideBoundaries, that will be used to overlap boundary processing with computations at inner points of the domain.\nouter_width[=nothing]: if hide_boundaries is specified, used to determine the decomposition of the domain into inner and outer regions.\nboundary_conditions[=nothing]: a tuple of boundary condition batches for each side of every spatial direction.\nasync[=true]: if set to false, will block the host until the kernel is finished executing.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Writers","page":"Modules","title":"Writers","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"Modules = [FastIce.Writers]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/modules/#FastIce.Writers.write_h5-Tuple{FastIce.Architectures.Architecture, FastIce.Grids.CartesianGrid, Any, Any}","page":"Modules","title":"FastIce.Writers.write_h5","text":"write_h5(arch::Architecture, grid::CartesianGrid, path, fields)\n\nWrite output fields in HDF5 format to a file on path.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Writers.write_h5-Tuple{FastIce.Architectures.Architecture{FastIce.Distributed.DistributedMPI}, FastIce.Grids.CartesianGrid, Any, Any}","page":"Modules","title":"FastIce.Writers.write_h5","text":"write_h5(arch::Architecture{DistributedMPI}, grid::CartesianGrid, path, fields)\n\nWrite output fields in HDF5 format to a file on path for global grid on distributed arch.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#FastIce.Writers.write_xdmf","page":"Modules","title":"FastIce.Writers.write_xdmf","text":"write_xdmf(arch::Architecture, grid::CartesianGrid, path, fields, h5_names, timesteps=Float64(0.0))\n\nWrite Xdmf metadata to path for corresponding h5_names and fields. Saving time-dependant data can be achieved upon passing a vector to h5_names and timesteps.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#FastIce.Writers.write_xdmf-2","page":"Modules","title":"FastIce.Writers.write_xdmf","text":"write_xdmf(arch::Architecture{DistributedMPI}, grid::CartesianGrid, path, fields, h5_names, timesteps=Float64(0.0))\n\nWrite Xdmf metadata to path for corresponding h5_names and fields for global grid on distributed arch. Saving time-dependant data can be achieved upon passing a vector to h5_names and timesteps.\n\n\n\n\n\n","category":"function"},{"location":"usage/runtests/#Running-tests","page":"Running tests","title":"Running tests","text":"","category":"section"},{"location":"usage/runtests/#CPU-tests","page":"Running tests","title":"CPU tests","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"To run the FastIce test suite on the CPU, simple run test from within the package mode or using Pkg:","category":"page"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"FastIce\")","category":"page"},{"location":"usage/runtests/#GPU-tests","page":"Running tests","title":"GPU tests","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"To run the FastIce test suite on CUDA or ROC backend (Nvidia or AMD GPUs), respectively, run the tests using Pkg adding following test_args:","category":"page"},{"location":"usage/runtests/#For-CUDA-backend-(Nvidia-GPUs):","page":"Running tests","title":"For CUDA backend (Nvidia GPUs):","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"FastIce\"; test_args=[\"--backend=CUDA\"])","category":"page"},{"location":"usage/runtests/#For-ROC-backend-(AMD-GPUs):","page":"Running tests","title":"For ROC backend (AMD GPUs):","text":"","category":"section"},{"location":"usage/runtests/","page":"Running tests","title":"Running tests","text":"using Pkg\nPkg.test(\"FastIce\"; test_args=[\"--backend=AMDGPU\"])","category":"page"},{"location":"#FastIce.jl","page":"Home","title":"FastIce.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FastIce.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Information about the STREAM project can be found in the GPU4GEO website","category":"page"}]
}
